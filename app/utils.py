# Generated by Copilot
import matplotlib
matplotlib.use('Agg')  # Use non-interactive backend for server
import matplotlib.pyplot as plt
import io
import base64
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import plotly.graph_objects as go
import plotly.express as px
from plotly.utils import PlotlyJSONEncoder
import json

class ChartGenerator:
    """Utility class for generating charts from questionnaire data"""
    
    @staticmethod
    def generate_response_timeline_chart(questionnaire, days=30):
        """Generate response timeline chart using Plotly"""
        from app.models import Response
        from app import db
        from sqlalchemy import func
        
        # Get response data for the last N days
        end_date = datetime.utcnow()
        start_date = end_date - timedelta(days=days)
        
        # Query responses grouped by date
        timeline_data = db.session.query(
            func.date(Response.submitted_at).label('date'),
            func.count(Response.id).label('count')
        ).filter(
            Response.questionnaire_id == questionnaire.id,
            Response.is_complete == True,
            Response.submitted_at >= start_date
        ).group_by(func.date(Response.submitted_at)).all()
        
        # Convert to DataFrame for easier manipulation
        if timeline_data:
            df = pd.DataFrame(timeline_data, columns=['date', 'count'])
            df['date'] = pd.to_datetime(df['date'])
        else:
            df = pd.DataFrame(columns=['date', 'count'])
        
        # Create date range to fill missing dates with 0
        date_range = pd.date_range(start=start_date.date(), end=end_date.date(), freq='D')
        date_df = pd.DataFrame({'date': date_range, 'count': 0})
        
        # Merge and fill missing dates
        if not df.empty:
            df = date_df.merge(df, on='date', how='left', suffixes=('', '_actual'))
            df['count'] = df['count_actual'].fillna(0)
            df = df[['date', 'count']]
        else:
            df = date_df
        
        # Create Plotly line chart
        fig = go.Figure()
        fig.add_trace(go.Scatter(
            x=df['date'],
            y=df['count'],
            mode='lines+markers',
            name='Daily Responses',
            line=dict(color='#0d6efd', width=3),
            marker=dict(size=8)
        ))
        
        fig.update_layout(
            title=f'Response Timeline - Last {days} Days',
            xaxis_title='Date',
            yaxis_title='Number of Responses',
            hovermode='x unified',
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)',
            font=dict(family="Segoe UI, Tahoma, Geneva, Verdana, sans-serif")
        )
        
        # Convert to JSON for JavaScript
        return json.dumps(fig, cls=PlotlyJSONEncoder)
    
    @staticmethod
    def generate_question_chart(question):
        """Generate chart for individual question statistics"""
        stats = question.get_answer_statistics()
        
        if not stats:
            return None
        
        if question.question_type in ['single_choice', 'multiple_choice']:
            # Pie chart for choice questions
            labels = list(stats.keys())
            values = list(stats.values())
            
            fig = go.Figure(data=[go.Pie(
                labels=labels,
                values=values,
                hole=0.3,
                textinfo='label+percent',
                textposition='inside'
            )])
            
            fig.update_layout(
                title=f'Responses Distribution',
                font=dict(family="Segoe UI, Tahoma, Geneva, Verdana, sans-serif"),
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(0,0,0,0)'
            )
            
        elif question.question_type == 'scale':
            # Bar chart for scale questions
            labels = ['1', '2', '3', '4', '5']
            values = [stats.get(label, 0) for label in labels]
            
            fig = go.Figure(data=[go.Bar(
                x=labels,
                y=values,
                marker_color=['#dc3545', '#fd7e14', '#ffc107', '#198754', '#0d6efd']
            )])
            
            fig.update_layout(
                title='Rating Distribution',
                xaxis_title='Rating',
                yaxis_title='Count',
                font=dict(family="Segoe UI, Tahoma, Geneva, Verdana, sans-serif"),
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(0,0,0,0)'
            )
        
        else:
            return None
        
        return json.dumps(fig, cls=PlotlyJSONEncoder)
    
    @staticmethod
    def generate_completion_rate_chart(questionnaire):
        """Generate completion rate donut chart"""
        total_started = questionnaire.responses.count()
        total_completed = questionnaire.responses.filter_by(is_complete=True).count()
        incomplete = total_started - total_completed
        
        if total_started == 0:
            return None
        
        fig = go.Figure(data=[go.Pie(
            labels=['Completed', 'Incomplete'],
            values=[total_completed, incomplete],
            hole=0.5,
            marker_colors=['#198754', '#dc3545']
        )])
        
        fig.update_layout(
            title='Completion Rate',
            annotations=[dict(text=f'{total_completed}/{total_started}', x=0.5, y=0.5, 
                            font_size=20, showarrow=False)],
            font=dict(family="Segoe UI, Tahoma, Geneva, Verdana, sans-serif"),
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)'
        )
        
        return json.dumps(fig, cls=PlotlyJSONEncoder)
    
    @staticmethod
    def generate_user_response_chart(questionnaire):
        """Generate user vs anonymous responses chart"""
        from app.models import Response
        
        user_responses = questionnaire.responses.filter_by(is_complete=True).filter(Response.user_id.isnot(None)).count()
        anonymous_responses = questionnaire.responses.filter_by(is_complete=True).filter(Response.user_id.is_(None)).count()
        
        if user_responses == 0 and anonymous_responses == 0:
            return None
        
        fig = go.Figure(data=[go.Bar(
            x=['Registered Users', 'Anonymous'],
            y=[user_responses, anonymous_responses],
            marker_color=['#0d6efd', '#6c757d']
        )])
        
        fig.update_layout(
            title='Response Types',
            yaxis_title='Number of Responses',
            font=dict(family="Segoe UI, Tahoma, Geneva, Verdana, sans-serif"),
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)'
        )
        
        return json.dumps(fig, cls=PlotlyJSONEncoder)
    
    @staticmethod
    def generate_matplotlib_chart(data, chart_type='bar', title='Chart', save_path=None):
        """Generate matplotlib chart and return as base64 string"""
        plt.style.use('default')
        fig, ax = plt.subplots(figsize=(10, 6))
        
        if chart_type == 'bar':
            bars = ax.bar(data.keys(), data.values(), color='#0d6efd', alpha=0.7)
            ax.set_ylabel('Count')
            
            # Add value labels on bars
            for bar in bars:
                height = bar.get_height()
                ax.text(bar.get_x() + bar.get_width()/2., height,
                       f'{int(height)}', ha='center', va='bottom')
        
        elif chart_type == 'pie':
            colors = ['#0d6efd', '#198754', '#ffc107', '#dc3545', '#6c757d']
            wedges, texts, autotexts = ax.pie(data.values(), labels=data.keys(), 
                                            autopct='%1.1f%%', colors=colors)
        
        ax.set_title(title, fontsize=16, fontweight='bold', pad=20)
        plt.tight_layout()
        
        # Save to string buffer
        img_buffer = io.BytesIO()
        plt.savefig(img_buffer, format='png', dpi=300, bbox_inches='tight')
        img_buffer.seek(0)
        
        # Convert to base64 for embedding in HTML
        img_str = base64.b64encode(img_buffer.getvalue()).decode()
        plt.close(fig)
        
        return f"data:image/png;base64,{img_str}"